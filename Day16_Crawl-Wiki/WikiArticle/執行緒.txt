執行緒（英語：thread）是作業系統能夠進行運算排程的最小單位。大部分情況下，它被包含在行程之中，是行程中的實際運作單位。一條執行緒指的是行程中一個單一順序的控制流，一個行程中可以並行多個執行緒，每條執行緒並列執行不同的任務。在Unix System V及SunOS中也被稱為輕量行程（lightweight processes），但輕量行程更多指核心執行緒（kernel thread），而把用戶執行緒（user thread）稱為執行緒。
執行緒是獨立排程和分派的基本單位。執行緒可以為作業系統核心排程的核心執行緒，如Win32執行緒；由用戶行程自行排程的用戶執行緒，如Linux平台的POSIX Thread；或者由核心與用戶行程，如Windows 7的執行緒，進行混合排程。
同一行程中的多條執行緒將共享該行程中的全部系統資源，如虛擬位址空間，檔案描述符和訊號處理等等。但同一行程中的多個執行緒有各自的呼叫棧（call stack），自己的暫存器環境（register context），自己的執行緒本地儲存（thread-local storage）。
一個行程可以有很多執行緒，每條執行緒並列執行不同的任務。
在多核或多CPU，或支援Hyper-threading的CPU上使用多執行緒程式設計的好處是顯而易見的，即提高了程式的執行吞吐率。在單CPU單核的電腦上，使用多執行緒技術，也可以把行程中負責I/O處理、人機互動而常被阻塞的部分與密集計算的部分分開來執行，編寫專門的workhorse執行緒執行密集計算，從而提高了程式的執行效率。
執行緒有四種基本狀態，分別為：
SUN Solaris作業系統使用的執行緒叫做UNIX International執行緒，支援核心執行緒、輕權行程和用戶執行緒。一個行程可有大量用戶執行緒；大量用戶執行緒復用少量的輕權行程，輕權行程與核心執行緒一一對應。用戶級執行緒在呼叫核心服務時（如檔案讀寫），需要「捆綁（bound）」在一個LWP上。永久捆綁（一個LWP固定被一個用戶級執行緒占用，該LWP移到LWP池之外）和臨時捆綁（從LWP池中臨時分配一個未被占用的LWP）。在呼叫系統服務時，如果所有LWP已被其他用戶級執行緒所占用（捆綁），則該執行緒阻塞直到有可用的LWP。如果LWP執行系統執行緒時阻塞（如read()呼叫），則目前捆綁在LWP上的用戶級執行緒也阻塞。
UNIX International執行緒的標頭檔是<thread.h>。[1]
其中flags包括：THR_BOUND（永久捆綁）, THR_NEW_LWP（建立新LWP放入LWP池），若兩者同時指定則建立兩個新LWP，一個永久捆綁而另一個放入LWP池。
POSIX執行緒（POSIX threads），簡稱Pthreads，是執行緒的POSIX標準。該標準定義了建立和操縱執行緒的一整套API。在類Unix作業系統（Unix、Linux、Mac OS X等）中，都使用Pthreads作為作業系統的執行緒[2][3][4]。Windows作業系統也有其移植版pthreads-win32[5]。
Pthreads執行緒的標頭檔是<pthread.h>。[6][7]
Win32執行緒是Windows API的一部分，上下文包括：暫存器、核心棧、執行緒環境塊和用戶棧。
Win32執行緒的標頭檔是<Windows.h>，僅適用於Windows作業系統。[8]
2011年8月12日，國際標準化組織（ISO）發布了第三個C++標準，即ISO/IEC 14882:2011，簡稱ISO C++ 11標準。該標準第一次把執行緒的概念引入C++標準庫。Windows平台執行的VS2012和Linux平台執行的g++4.7，都完美支援C++11執行緒。
C++ 11執行緒的標頭檔是<thread>。[9]
2011年12月8日，國際標準化組織（ISO）發布了第三個C語言標準，即ISO 9899:2011，簡稱ISO C 11標準。該標準第一次把執行緒的概念引入C語言標準庫。
C11執行緒僅僅是個「建議標準」，也就是說100%遵守C11標準的C編譯器是可以不支援C11執行緒的。根據C11標準的規定，只要編譯器預定義了 __STDC_NO_THREADS__(C11)，就可以沒有<threads.h>標頭檔，自然也就也沒有下列函式。
C11執行緒的標頭檔是<threads.h>。[10]
