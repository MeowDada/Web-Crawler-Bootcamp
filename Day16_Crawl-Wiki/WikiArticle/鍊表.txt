連結串列（Linked list）是一種常見的基礎資料結構，是一種線性表，但是並不會按線性的順序儲存資料，而是在每一個節點裡存到下一個節點的指標(Pointer)。由於不必須按順序儲存，連結串列在插入的時候可以達到O(1)的複雜度，比另一種線性表順序表快得多，但是尋找一個節點或者存取特定編號的節點則需要O(n)的時間，而順序表相應的時間複雜度分別是O(logn)和O(1)。
使用連結串列結構可以克服陣列連結串列需要預先知道資料大小的缺點，連結串列結構可以充分利用電腦記憶體空間，實現靈活的記憶體動態管理。但是連結串列失去了陣列隨機讀取的優點，同時連結串列由於增加了結點的指標域，空間開銷比較大。
在電腦科學中，連結串列作為一種基礎的資料結構可以用來生成其它類型的資料結構。連結串列通常由一連串節點組成，每個節點包含任意的實例資料（data fields）和一或兩個用來指向上一個/或下一個節點的位置的連結（"links"）。連結串列最明顯的好處就是，常規陣列排列關聯專案的方式可能不同於這些資料專案在記憶體或磁碟上順序，資料的存取往往要在不同的排列順序中轉換。而連結串列是一種自我指示資料類型，因為它包含指向另一個相同類型的資料的指標（連結）。連結串列允許插入和移除表上任意位置上的節點，但是不允許隨機存取。連結串列有很多種不同的類型：單向連結串列，雙向連結串列以及迴圈連結串列。
連結串列可以在多種程式語言中實現。像Lisp和Scheme這樣的語言的內建資料類型中就包含了連結串列的存取和操作。程式語言或物件導向語言，如C/C++和Java依靠易變工具來生成連結串列。
連結串列開發於1955-56，由當時所屬於蘭德公司（英語：RAND Corporation）的艾倫紐維爾（Allen Newell），克里夫肖（Cliff Shaw）和赫伯特西蒙（Herbert Simon）在他們編寫的資訊處理語言（IPL）中做為原始資料類型所編寫。IPL被作者們用來開發幾種早期的人工智慧程式，包括邏輯推理機，通用問題解算器和一個電腦象棋程式。
連結串列中最簡單的一種是單向連結串列，它包含兩個域，一個資訊域和一個指標域。這個連結指向列表中的下一個節點，而最後一個節點則指向一個空值。
一個單向連結串列的節點被分成兩個部分。第一個部分儲存或者顯示關於節點的資訊，第二個部分儲存下一個節點的位址。單向連結串列只可向一個方向遍歷。
連結串列最基本的結構是在每個節點儲存資料和到下一個節點的位址，在最後一個節點儲存一個特殊的結束標記，另外在一個固定的位置儲存指向第一個節點的指標，有的時候也會同時儲存指向最後一個節點的指標。一般尋找一個節點的時候需要從第一個節點開始每次存取下一個節點，一直存取到需要的位置。但是也可以提前把一個節點的位置另外儲存起來，然後直接存取。當然如果只是存取資料就沒必要了，不如在連結串列上儲存指向實際資料的指標。這樣一般是為了存取連結串列中的下一個或者前一個（需要儲存反向的指標，見下面的雙向連結串列）節點。
相對於下面的雙向連結串列，這種普通的，每個節點只有一個指標的連結串列也叫單向連結串列，或者單連結串列，通常用在每次都只會按順序遍歷這個連結串列的時候（例如圖的鄰接表，通常都是按固定順序存取的）。
連結串列也有很多種不同的變化：
一種更複雜的連結串列是「雙向連結串列」或「雙面連結串列」。每個節點有兩個連接：一個指向前一個節點，（當此「連接」為第一個「連接」時，指向空值或者空串列）；而另一個指向下一個節點，（當此「連接」為最後一個「連接」時，指向空值或者空串列）
在一些低階語言中, XOR-linking 提供一種在雙向連結串列中通過用一個詞來表示兩個連結（前後），我們通常不提倡這種做法。
雙向連結串列也叫雙連結串列。雙向連結串列中不僅有指向後一個節點的指標，還有指向前一個節點的指標。這樣可以從任何一個節點存取前一個節點，當然也可以存取後一個節點，以至整個連結串列。一般是在需要大批次的另外儲存資料在連結串列中的位置的時候用。雙向連結串列也可以配合下面的其他連結串列的擴充使用。
由於另外儲存了指向連結串列內容的指標，並且可能會修改相鄰的節點，有的時候第一個節點可能會被刪除或者在之前添加一個新的節點。這時候就要修改指向首個節點的指標。有一種方便的可以消除這種特殊情況的方法是在最後一個節點之後、第一個節點之前儲存一個永遠不會被刪除或者移動的虛擬節點，形成一個下面說的迴圈連結串列。這個虛擬節點之後的節點就是真正的第一個節點。這種情況通常可以用這個虛擬節點直接表示這個連結串列，對於把連結串列單獨的存在陣列里的情況，也可以直接用這個陣列表示連結串列並用第0個或者第-1個（如果編譯器支援）節點固定的表示這個虛擬節點。
在一個 迴圈連結串列中, 首節點和末節點被連接在一起。這種方式在單向和雙向連結串列中皆可實現。要轉換一個迴圈連結串列，你開始於任意一個節點然後沿著列表的任一方向直到返回開始的節點。再來看另一種方法，迴圈連結串列可以被視為「無頭無尾」。這種列表很利於節約資料儲存快取， 假定你在一個列表中有一個物件並且希望所有其他物件疊代在一個非特殊的排列下。
指向整個列表的指標可以被稱作存取指標。
迴圈連結串列中第一個節點之前就是最後一個節點，反之亦然。迴圈連結串列的無邊界使得在這樣的連結串列上設計演算法會比普通連結串列更加容易。對於新加入的節點應該是在第一個節點之前還是最後一個節點之後可以根據實際要求靈活處理，區別不大(詳見下面實例代碼)。當然，如果只會在最後插入資料（或者只會在之前），處理也是很容易的。
另外有一種類比的迴圈連結串列，就是在存取到最後一個節點之後的時候，手工的跳轉到第一個節點。存取到第一個節點之前的時候也一樣。這樣也可以實現迴圈連結串列的功能，在直接用迴圈連結串列比較麻煩或者可能會出現問題的時候可以用。
塊狀連結串列本身是一個連結串列，但是連結串列儲存的並不是一般的資料，而是由這些資料組成的順序表。每一個塊狀連結串列的節點，也就是順序表，可以被叫做一個塊。
塊狀連結串列通過使用可變的順序表的長度和特殊的插入、刪除方式，可以在達到



O
(


n


)


{\displaystyle O({\sqrt {n}})}

的複雜度。塊狀連結串列另一個特點是相對於普通連結串列來說節省記憶體，因為不用儲存指向每一個資料節點的指標。
根據情況，也可以自己設計連結串列的其它擴充。但是一般不會在邊上附加資料，因為連結串列的點和邊基本上是一一對應的（除了第一個或者最後一個節點，但是也不會產生特殊情況）。不過有一個特例是如果連結串列支援在連結串列的一段中把前和後指標反向，反向標記加在邊上可能會更方便。
對於非線性的連結串列，可以參見相關的其他資料結構，例如樹、圖。另外有一種基於多個線性連結串列的資料結構：跳表，插入、刪除和尋找等基本操作的速度可以達到O(nlogn)，和平衡樹一樣。
連結串列中的節點不需要以特定的方式儲存，但是集中儲存也是可以的，主要分下面這幾種具體的儲存方法：
連結串列用來構建許多其它資料結構，如堆疊，佇列和他們的衍生。
節點的資料域也可以成為另一個連結串列。通過這種手段，我們可以用列表來構建許多鏈性資料結構；這個實例產生於Lisp程式語言，在Lisp中連結串列是初級資料結構，並且現在成為了常見的基礎編程模式。
有時候，連結串列用來生成聯合陣列，在這種情況下我們稱之為聯合數列。這種情況下用連結串列會優於其它資料結構，如自平對分尋找樹（self-balancing binary search trees）甚至是一些小的資料集合。不管怎樣，一些時候一個連結串列在這樣一個樹中建立一個節點子集，並且以此來更有效率地轉換這個集合。
範例代碼是一個ADT（抽象資料類型）雙向環形連結串列的基本操作部分的實例（未包含執行緒安全機制），全部遵從ANSI C標準。
以下代碼摘自Linux核心2.6.21.5原始碼(部分)，展示了連結串列的另一種實現思路，未採用ANSI C標準，採用GNU C標準，遵從GPL著作權許可。
常用於組織檢索較少，而刪除、添加、遍歷較多的資料。
如果與上述情形相反，應採用其他資料結構或者與其他資料結構組合使用。
