在計算理論中，非確定有限狀態自動機或非確定有限自動機（NFA）是對每個狀態和輸入符號對可以有多個可能的下一個狀態的有限狀態自動機。這區別於確定有限狀態自動機（DFA），它的下一個可能狀態是唯一確定的。儘管DFA和NFA有不同的定義，在形式理論中可以證明它們是等價的；就是說，對於任何給定NFA，都可以構造一個等價的DFA，反之亦然：通過使用冪集構造。兩種類型的自動機只辨識正規語言。非確定有限自動機有時被稱為有限類型的子移位（subshift）。非確定有限狀態自動機可推廣為概率自動機，它為每個狀態轉移指派概率。
非確定有限自動機是Michael O. Rabin和Dana Scott在1959年介入的[1]，他們證明了它與確定自動機的等價性。
NFA同DFA一樣，消耗輸入符號的字串。對每個輸入符號它變換到一個新狀態直到所有輸入符號到被耗盡。
不像DFA，非確定意味著對於任何輸入符號，它的下一個狀態不是唯一確定的，可以是多個可能狀態中的任何一個。因此在形式定義中，一般都談論狀態冪集的子集：轉移函式不提供一個單一狀態，而是提供所有可能狀態的某個子集。
一種擴充的NFA是NFA-λ（也叫做NFA-ε或有ε移動的NFA），它允許到新狀態的變換不消耗任何輸入符號。例如，如果它處於狀態1，下一個輸入符號是a，它可以移動到狀態2而不消耗任何輸入符號，因此就有了歧義：在消耗字母a之前系統是處於狀態1還是狀態2呢?由於這種歧義性，可以更加方便的談論系統可以處在的可能狀態的集合。因此在消耗字母a之前，NFA-ε可以處於集合{1,2}內的狀態中的任何一個。等價的說，你可以想像這個NFA同時處於狀態1和狀態2:這給出了對冪集構造的非正式提示：等價於這個NFA的DFA被定義為此時處於狀態q={1,2}中。不消耗輸入符號的到新狀態的變換叫做λ轉移或ε轉移。它們通常標記著希臘字母λ或ε。
接受輸入的概念類似於DFA。當最後的輸入字元被消耗的時候，NFA接受這個字串，若且唯若有某個轉移集合把它帶到一個接受狀態。等價的說，它拒絕這個字串，如果不管應用什麼轉移，它都不能結束於接受狀態。
通常定義兩種類似類型的NFA: NFA和「有ε-移動的NFA」。普通的NFA被定義為5-元組(Q, Σ, T, q0, F)，它構成自
這裡的P(Q)指示Q的冪集。「有ε-移動的NFA」（有時也叫做「NFA-ε」或「NFA-λ」）修訂轉移函式為允許空字串ε作為可能的輸入，結果為
可以證明普通NFA和有ε移動的NFA是等價的，給定任何一個都可以構造出辨識同樣語言的另一個。
機器開始於任意初始狀態並讀取來自它的符號表的符號的字串。自動機使用狀態轉移函式T來使用目前狀態，和剛讀入的符號或空字串來確定下一個狀態。但是，「NFA的下一個狀態不只依賴於目前輸入事件，還依賴於任意數目的後續輸入事件。直到這些後續事件出現才有可能確定這個機器所處的狀態」 [2]。如果在自動機完成讀取的時候，它處於接受狀態，則稱NFA接受了這個字串，否則稱為它拒絕了這個字串。
NFA接受的所有字串的集合是NFA接受的語言。這個語言是正規語言。
對於所有NFA都可以找到接受同樣語言的一個確定有限狀態自動機（DFA）。所以出於實現（可能）更簡單的機器的目的把現存的NFA轉換成DFA是可行的。這是使用冪集構造進行的，這可能導致在必需狀態的數目上的指數增長。冪集構造的形式證明在這裡給出。
對於有狀態的可數無限集合的非確定有限自動機，冪集構造給出有狀態的連續統的確定自動機因為可數無限集合的冪集是連續統：




2


ℵ

0




=

ℵ

1




{\displaystyle 2^{\aleph _{0}}=\aleph _{1}}

)。在這種情況下，為了使狀態轉移有意義，狀態的集合必須被賦予一個拓撲。這種系統叫做拓撲自動機。
對於所有



p
,
q
∈
Q


{\displaystyle p,q\in Q}

，寫



p




→


ϵ




q


{\displaystyle p{\stackrel {\epsilon }{\rightarrow }}q}

若且唯若從



p


{\displaystyle p}

沿著零或更多個



ϵ


{\displaystyle \epsilon }

箭頭前進可到達



q


{\displaystyle q}

。換句話說，



p




→


ϵ




q


{\displaystyle p{\stackrel {\epsilon }{\rightarrow }}q}

若且唯若存在




q

1


,

q

2


,
⋯

q

k


∈
Q


{\displaystyle q_{1},q_{2},\cdots q_{k}\in Q}

這裡的



k
≥
0


{\displaystyle k\geq 0}

使得
對於任何



p
∈
Q


{\displaystyle p\in Q}

，從p可到達的狀態的集合叫做p的ε-閉包，並寫為
對於



P
⊂
Q


{\displaystyle P\subset Q}

的任何子集，定義P的ε-閉包為
ε-轉移是傳遞的，這可以證明，對於所有




q

0


,

q

1


,

q

2


∈
Q


{\displaystyle q_{0},q_{1},q_{2}\in Q}

和



P
⊂
Q


{\displaystyle P\subset Q}

，如果




q

1


∈
E
(
{

q

0


}
)


{\displaystyle q_{1}\in E(\{q_{0}\})}

且




q

2


∈
E
(
{

q

1


}
)


{\displaystyle q_{2}\in E(\{q_{1}\})}

，則




q

2


∈
E
(
{

q

0


}
)


{\displaystyle q_{2}\in E(\{q_{0}\})}

。
類似的，如果




q

1


∈
E
(
P
)


{\displaystyle q_{1}\in E(P)}

且




q

2


∈
E
(
{

q

1


}
)


{\displaystyle q_{2}\in E(\{q_{1}\})}

則




q

2


∈
E
(
P
)


{\displaystyle q_{2}\in E(P)}


設x是字母表Σ上的字串。一個NFA-ε M接受字串x，如果存在x的形如x1x2 ... xn的表示，這裡的xi ∈(Σ ∪{ε})，和狀態序列 
p0,p1, ..., pn二者，這裡的pi ∈ Q，滿足下列條件：
特別注意某些字母xi可以是{ε}；它們不是選擇自單獨的Σ，而是來自Σ ∪{ε}。
有多種方式實現NFA:
下面的例子展示一個NFA M，帶有二進位字母表，它確定輸入是否包含偶數個0或偶數個1。設M =(Q, Σ, T, s0, F)這裡的
M的狀態圖是：
M可以被看作兩個DFA的並集：一個有狀態{S2, S1}而另一個有狀態{S3, S4}。 
M的語言可以描述為如下正規表示式給出的正規語言：
NFA與確定有限自動機（DFA，或簡稱FA）的辨識能力是一樣的，因而兩者是等價的。每個FA也可以寫成NFA的形式，只要把轉換函式由



δ
(

q

n
−
1


,
x
)
=

q

n




{\displaystyle \delta (q_{n-1},x)=q_{n}}

改寫成



δ
(

q

n
−
1


,
x
)
=
{

q

n


}


{\displaystyle \delta (q_{n-1},x)=\{q_{n}\}}

就可以，即是與之等價的NFA的轉換函式的輸出結果即是FA的轉換函式的輸出結果的單元集。反之，對任何NFA M=(Q, Σ, δ, q0, F)來說，如果它可以接受語言L，則必定存在某個FA M1=(Q1, Σ, δ1, q1, F1)，也可以接受L。可以從「狀態」的定義下手「消除」NFA的不確定性。NFA的轉換函式的輸出結果本為狀態集合Q的子集合，現在把這一個子集合當成一個狀態看待，即是FA M1中的狀態是NFA中狀態集合的子集合。這技巧叫做子集合的建構（subset construction）。即是





Q

1


=

2

Q



 and 


q

1


=
{

q

0


}

 for 

q
∈

Q

1



 and 

a
∈
Σ
,

δ

1


(
q
,
a
)
=

⋃

p
∈
q


δ
(
p
,
a
)


{\displaystyle Q_{1}=2^{Q}{\text{ and }}q_{1}=\{q_{0}\}{\text{ for }}q\in Q_{1}{\text{ and }}a\in \Sigma ,\delta _{1}(q,a)=\bigcup _{p\in q}\delta (p,a)}







F

1


=
{
q
∈

Q

1



|

q
∩
F
≠
0
}


{\displaystyle F_{1}=\{q\in Q_{1}|q\cap F\neq 0\}}


NFA和DFA是等價的，如果一個語言可被一個NFA辨識，則它也可以被一個DFA辨識，反之亦然。這種等價性的建立是重要和有用的。有用是因為構造辨識給定語言的NFA有時比構造這個語言的DFA要容易很多。重要是因為NFA可以用來減少建立計算理論中很多重要性質的數學工作的複雜性。例如，使用NFA比使用DFA證明下列性質要更加容易：
（i）兩個正規語言的並集是正規的。
（ii）兩個正規語言的串接是正規的。
（iii）一個正規語言的Kleene閉包是正規的。
