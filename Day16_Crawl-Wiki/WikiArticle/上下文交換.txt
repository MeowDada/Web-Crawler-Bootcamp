上下文交換(英語：context switch)，又稱環境切換，電腦術語，是一個儲存和重建CPU的狀態 (內文)，因此令多個行程(process)可以分享單一CPU資源的計算過程。要交換CPU上的行程時，必需先行儲存目前行程的狀態，再將欲執行的行程之狀態讀回CPU中。[1]
上下文交換通常是計算密集型的，作業系統中的許多設計都是針對上下文交換的最佳化。在行程間切換需要消耗一定的時間進行相關的管理工作——包括暫存器和記憶體對映的儲存與讀取、更新各種內部的表等等。處理器或者作業系統不同，上下文交換時所涉及的內容也不盡相同。比如在Linux核心中，上下文交換需要涉及暫存器、棧指標、程式計數器的交換，但和位址空間的交換無關（雖然行程在進行上下文交換時也需要做位址空間的交換）[2][3]。用戶態執行緒之間也會發生類似的上下文交換，但這樣的交換非常輕量。
有三種可能的情況會發生上下文交換，分別為：
最常見的，在一些排程(scheduling)演算法內，其中行程有時候需要暫時離開CPU，讓另一個行程進來CPU運作。在先佔式多工系統中，每一個行程都將輪流執行不定長度的時間，這些時間段落稱為時間片。如果行程並非自願讓出CPU(例如執行I/O操作時，行程就需放棄CPU使用權)，當時限到時，系統將產生一個定時中斷，作業系統將排定由其它的行程來執行。此機制用以確保CPU不致被較依賴處理器運算的行程壟斷。若無定時中斷，除非行程自願讓出CPU，否則該行程將持續執行。對於擁有較多I/O指令的行程，往往執行不了多久，便需要讓出CPU；而較依賴處理器的行程相對而言I/O操作較少，反而能一直持續使用CPU，便形成了壟斷現象。
在接受到中斷（Interrupt）的時候，CPU必須要進行上下文交換。
當用戶態和核心態交換發生的時候，並不需要進行上下文交換；並且用戶態和kernel mode的交換本身並不是一個上下文交換。不過，根據作業系統的不同，有時候會在此時進行一次上下文交換的步驟。
在一次交換中，第一個行程的狀態要被紀錄在某個地方，這樣當排程器(scheduler)要回到這個行程時，才可以重建這個行程並且繼續運算。
這裡所謂「行程的狀態」，包含了這個行程使用的所有暫存器(register)，特別是程式計數器；加上所有作業系統可能需要的特定資料。這些資料一般以名為過程控制段(process control block，PCB)的資料結構儲存起來。
上下文交換可分為主要由軟體實現或由硬體實現。部分中央處理器，比如Intel 80386[4]或同系列更高階的處理器，就具備支援上下文交換的硬體設計。
